#!/usr/bin/env bash

function log() {
  echo "${0##*/}: $1" >&2
}

function is_readable_file() {
  [[ -f "$1" && -r "$1" ]]
}

function executable_exists() {
  # executables / no builtins, aliases, or functions
  type -aPf "$1" > /dev/null 2>&1
}

function command_exists() {
  # executables and builtins / no aliases or functions
  type -Pf "$1" > /dev/null 2>&1
}

function is_arch() {
  grep --quiet '^ID=arch$\|^ID_LIKE=arch$' '/etc/os-release'
}

function path_remove() {
  PATH=$(echo -n "$PATH" | awk -v RS=: -v ORS=: '$0 != "'"$1"'"' | sed 's/:$//')
}

function path_append() {
  path_remove "$1" && PATH="$PATH:$1"
}

function path_prepend() {
  path_remove "$1" && PATH="$1:$PATH"
}

function contains_word() {
  grep --quiet --fixed-strings --ignore-case --word-regex "$1"
}

function is_distro() {
  hostnamectl | grep --fixed-strings 'Operating System:' | cut --delimiter=':' --fields=2 | contains_word "$1"
}

function is_desktop_env() {
  set +u
  local xcd="${XDG_CURRENT_DESKTOP}"
  set -u
  echo "${xcd}" | contains_word "$1"
}

function is_personal() {
  set +u
  local pow="${PERSONAL_OR_WORK}"
  set -u
  [[ "${pow}" == 'personal' ]]
}

function is_work() {
  set +u
  local pow="${PERSONAL_OR_WORK}"
  set -u
  [[ "${pow}" == 'work' ]]
}

function is_desktop() {
  set +u
  local dol="${DESKTOP_OR_LAPTOP}"
  set -u
  [[ "${dol}" == 'desktop' ]]
}

function is_laptop() {
  set +u
  local dol="${DESKTOP_OR_LAPTOP}"
  set -u
  [[ "${dol}" == 'laptop' ]]
}

function is_headless() {
  set +u
  local hl="${HEADLESS}"
  set -u
  [[ "${hl}" == 'yes' ]]
}

function prompt_ny() {
  local prompt_reply=''
  while [[ "${prompt_reply}" != 'y' && "${prompt_reply}" != 'n' ]]; do
    read -rp "$1 [Y/n]: " prompt_reply
    if [[ ${prompt_reply} == [yY] ]]; then
      prompt_reply='y'
    elif [[ "${prompt_reply}" == '' || "${prompt_reply}" == [nN] ]]; then
      prompt_reply='n'
    fi
  done
  [[ "${prompt_reply}" == 'y' ]]
}

function prompt_yn() {
  local prompt_reply=''
  while [[ "${prompt_reply}" != 'y' && "${prompt_reply}" != 'n' ]]; do
    read -rp "$1 [Y/n]: " prompt_reply
    if [[ "${prompt_reply}" == '' || ${prompt_reply} == [yY] ]]; then
      prompt_reply='y'
    elif [[ "${prompt_reply}" == [nN] ]]; then
      prompt_reply='n'
    fi
  done
  [[ "${prompt_reply}" == 'y' ]]
}

function prompt_for_value() {
  read -rp "$1 [$2]: " prompt_reply
  if [[ -z "${prompt_reply}" ]]; then
    echo "$2"
  else
    echo "${prompt_reply}"
  fi
}

# https://unix.stackexchange.com/questions/9123/is-there-a-one-liner-that-allows-me-to-create-a-directory-and-move-into-it-at-th/9124#9124
function mkcd() {
  [[ "$#" -ne 1 ]] && echo "${0##*/}: Expected exactly 1 argument" >&2 && return 2
  case "$1" in
    */.. | */../) cd -- "$1" || return 2 ;; # that doesn't make any sense unless the directory already exists
    /*/../*) (cd "${1%/../*}/.." && mkdir --parents "./${1##*/../}") && cd -- "$1" || return 2 ;;
    /*) mkdir --parents "$1" && cd "$1" || return 2 ;;
    */../*) (cd "./${1%/../*}/.." && mkdir --parents "./${1##*/../}") && cd "./$1" || return 2 ;;
    ../*) (cd .. && mkdir --parents "${1#.}") && cd "$1" || return 2 ;;
    *) mkdir --parents "./$1" && cd "./$1" || return 2 ;;
  esac
}

function cl() {
  cd "$@" && eval ll
}

function fff() {
  command fff "$@"
  cd "$(cat "${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d")" || return 2
}

function functions() {
  typeset -F | cut --delimiter=' ' --fields=3 | while read func; do
    (
      shopt -s extdebug
      declare -F "${func}"
    ) | awk '{ print $1, $3":"$2 }'
  done |
    sed "s#${HOME}#~#g" |
    column --table --table-columns 'FUNCTION,SOURCE' --table-truncate 1
}

function aliases() {
  PS4='+$BASH_SOURCE ' BASH_XTRACEFD=7 bash -xic ':' 7> >(
    grep --perl-regexp '^\++\S+ alias ' |
      sed 's/^\+*//' |
      sed --regexp-extended "s#([^\])'#\1#g" |
      awk -F' alias ' -v OFS='‽' '{ print $2, $1 }' |
      LC_COLLATE=C sort
  ) |
    sed "s#${HOME}#~#g" |
    column --separator '‽' --table --table-columns 'ALIAS,SOURCE' --table-columns-limit 2 --table-truncate 1
}

function history-commands() {
  HISTTIMEFORMAT="" history |
    awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' |
    grep -v "./" |
    column -c3 -s " " -t |
    sort -nr |
    nl
}
